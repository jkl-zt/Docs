# 前端安全事项 #
-------------

## 简介 ##
##### 跨站脚本攻击(XSS) #####

``XSS`` 全称(``Cross Site Scripting``) 跨站脚本攻击， 是Web程序中最常见的漏洞。指攻击者在网页中嵌入客户端脚本(例如``JavaScript``), 当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的.  比如获取用户的``Cookie``，导航到恶意网站,携带木马等。

-------------

## XSS的危害 ##

### 1、盗取cookie ###

   通过``XSS``攻击，由于注入代码是在受害者的浏览器上执行，因此能够很方便地窃取到受害者的``Cookie``信息。当受害者的浏览器执行脚本的时候，就会自动访问攻击者建立的网站，打开其中的某个网页，将受害者浏览器的``Cookie``信息给记录下来。这样，攻击者就得到了用户的``Cookie``信息。得到受害者的``Cookie``信息后，攻击者可以很方便地冒充受害者，从而拥有其在目标服务器上的所有权限，相当于受害者的身份认证被窃取了。

### 2、钓鱼攻击 ###

   所谓钓鱼攻击就是构建一个钓鱼页面，诱骗受害者在其中输入一些敏感信息，然后将其发送给攻击者。利用``XSS``的注入脚本，我们也可以很方便地注入钓鱼页面的代码，从而引导钓鱼攻击。注入代码后，会在原来的页面上，插入一段表单，要求用户输入自己的用户名和密码，而当用户点击“登录”按钮后，则会执行黑客事前插入好的函数，将用户的输入发送到攻击者指定的网站上去。这样，攻击者就成功窃取了该用户的账号信息。和一般的钓鱼攻击不同，``XSS``引导的钓鱼攻击由于是对用户信任的网站页面进行修改的。

### 3、CSRF攻击 ###

   比如我们注入如下的HTML代码：

    <imgsrc = “http://www.bank.com/transfer.do?toAct=123456&money=10000>

   假如上面的代码中所访问的是某个银行网站的转账服务，则当受害者的浏览器运行这段脚本时，就会向攻击者指定的账户（示例的``123456``）执行转账操作。由于这个转账请求是在受害者的浏览器中运行的，因此浏览器也会自动将受害者的``Cookie``信息一并发送。这样，发送的请求就好像是受害者自己发送的一样，银行网站也将认可这个请求的合法性，攻击者也就达到了伪造请求的目的。

### 4、传播恶意软件 ###

　 除了直接注入恶意脚本以外，通过``XSS``攻击，攻击者也可以很方便地在脚本中引入一些恶意软件，比如病毒、木马、蠕虫等等。例如，攻击者可以在某个自己建立的页面上放置一些恶意软件，然后用``XSS``注入的方式，插入一段引用该页面的脚本。这样当受害者的浏览器执行这段脚本的时候，就会自动访问放置了恶意软件的页面，从而受到这些恶意软件的感染。

-----------

## XSS预防 ##

##### 1. 输入过滤 #####

   对用户的所有输入数据进行检测，比如过滤其中的“``<`` | ``>`` | ``/``”等可能导致脚本注入的特殊字符，或者过滤“``script``”、“``javascript``”等脚本关键字，或者对输入数据的长度进行限制等等。同时，我们也要考虑用户可能绕开``ASCII``码，使用十六进制编码来输入脚本。因此，对用户输入的十六进制编码，我们也要进行相应的过滤。只要能够严格检测每一处交互点，保证对所有用户可能的输入都进行检测和XSS过滤，就能够有效地阻止XSS攻击。

##### 2. 输出编码 #####

   通过前面对``XSS``攻击的分析，我们可以看到，之所以会产生``XSS``攻击，就是因为``Web``应用程序将用户的输入直接嵌入到某个页面当中，作为该页面的``HTML``代码的一部分。因此，当``Web``应用程序将用户的输入数据输出到目标页面中时，只要用``Html Encoder``等工具先对这些数据进行编码，然后再输出到目标页面中。这样，如果用户输入一些``HTML``的脚本，也会被当成普通的文字，而不会成为目标页面``HTML``代码的一部分得到执行。

##### 3. Cookie防盗 #####

   利用``XSS``攻击，攻击者可以很方便地窃取到合法用户的``Cookie``信息。因此，对于``Cookie``，我们可以采取以下的措施。首先，我们要尽可能地避免在``Cookie``中泄露隐私，如用户名、密码等；其次，我们可以将``Cookie``信息利用``MD5``等``Hash``算法进行多次散列后存放；再次，为了防止重放攻击，我们也可以将``Cookie``和``IP``进行绑定，这样也可以阻止攻击者冒充正常用户的身份。

##### 4、CSRF 防御 #####

- **验证码**

	
    > 几乎所有人都知道验证码，但验证码不单单用来防止注册机的暴力破解，还可以有效防止``CSRF``的攻击。验证码算是对抗``CSRF``攻击最简洁有效的方法。但使用验证码的问题在于，不可能在用户的所有操作上都需要输入验证码.只有一些关键的操作，才能要求输入验证码。不过随着``HTML5``的发展。利用``canvas``标签，前端也能识别验证码的字符，让``CSRF``生效。

- **Token**
 
	> ``CSRF``能攻击成功，根本原因是：操作所带的参数均被攻击者猜测到。既然知道根本原因，我们就对症下药，利用``Token``。当向服务器传参数时，带上``Token``。这个``Token``是一个随机值，并且由服务器和用户同时持有。当用户提交表单时带上``Token``值，服务器就能验证表单和``session``中的``Token``是否一致。

-------------
## XSS的具体表现和防守样例 ##

### 1、XSS输入框注入 ###

##### 表现： #####

`` xss input `` 注入的表现方式：
通过向输入框（ `` input `` | `` textarea `` ）等控件输入危险文本:

    <script>alert(document.cookie);</script>

##### 应对方案： #####

转化敏感字符串，如：  " ``<script> `` "  转化为  " `` %3Cscript%3E `` "  ;

### 2、XSS标签注入 ###

##### 表现： #####

通过标签闭合来引起页面变动，如通过下面代码：

``````javascript
    "/><div style="position:absolute;left:0px;top:0px;"><iframe src="http://www.baidu.com" FRAMEBORDER=0 width=1000 height=900/></div><a href="
``````
    
向 `` DOM `` 插入危险 `` Iframe `` 来劫持网页;

##### 应对方案： #####

屏蔽关键字：适当对输入框作输入监听，将  `` < `` | `` > `` | `` style `` | `` div `` | `` href `` | `` iframe ``  等等关键字的输入过滤；

### 3、基于文档的脚本注入 ###

##### 表现： #####

页面本身包含一些 `` DOM `` 对象的操作，如果未对输入的参数进行处理，可能会导致执行恶意脚本。如下面一些 `` DOM `` 操作

例如页面：

    <SCRIPT>
        var pos=document.URL.indexOf("name=")+5;
        document.write(document.URL.substring(pos,document.URL.length));
    </SCRIPT>

攻击者使用如下的 `` URL `` 访问时，则非常危险：

    http://abc.com/?name=<script>alert(document.cookie)</script>;

形成注入，想要执行一些黑客想要得到的信息；

##### 应对方案： #####

如果必须这么做法的话，编码的时候一定要做验证：

    if (name.match(/^[a-zA-Z0-9]$/)){
        document.write(name);
    } else {
        window.alert("Security error");
    }
### 4、非持久化的XSS ###

##### 表现： #####

`` Reflected cross-site scripting``,也被称为``None-Persistent cross-site scripting``，即，非持久化的XSS攻击，是我们通常所说的，也是最常用，使用最广的一种方式。它通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。它的特点是非持久化，必须用户点击带有特定参数的链接才能引起。

##### 应对方案： #####

如果可以的话，在服务器端做链接验证，不合法的``url``统一跳转至错误页面并给出错误提示。

### 5、持久性XSS ###

##### 表现： #####

`` Persistent cross-site scripting ``,持久化XSS攻击，指的是恶意脚本代码被存储进被攻击的数据库，当其他用户正常浏览网页时，站点从数据库中读取了非法用户存入非法数据，恶意脚本代码被执行。这种攻击类型通常在留言板等地方出现。

##### 应对方案： #####

及时扫描数据库，或者通过其他方式，清理数据库危险数据。

### 6、CSRF跨站请求伪造 ###

``CSRF``（``Cross-site request forgery``跨站请求伪造，也被称为“``one click attack``”或者``session riding``，通常缩写为``CSRF``或者``XSRF``，是一种对网站的恶意利用。尽管听起来像跨站脚本（``XSS``），但它与``XSS``非常不同，并且攻击方式几乎相左。``XSS``利用站点内的信任用户，而``CSRF``则通过伪装来自受信任用户的请求来利用受信任的网站。与``XSS``攻击相比，``CSRF``攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比``XSS``更具危险性。

##### 表现： #####

比如我们注入如下的HTML代码：

    <imgsrc = “http://www.bank.com/transfer.do?toAct=123456&money=10000>

假如上面的代码中所访问的是某个银行网站的转账服务，则当受害者的浏览器运行这段脚本时，就会向攻击者指定的账户（示例的``123456``）执行转账操作。由于这个转账请求是在受害者的浏览器中运行的，因此浏览器也会自动将受害者的``Cookie``信息一并发送。这样，发送的请求就好像是受害者自己发送的一样，银行网站也将认可这个请求的合法性，攻击者也就达到了伪造请求的目的。

##### 应对方案： #####

服务器端更可能的进行严格数据验证。

> *3/27/2015 3:46:32 PM by jklzt*
